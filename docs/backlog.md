### **Product Backlog Final - Projeto FGH (Completo)**

| Pri | User Story | Critérios de Aceitação | Critérios de Qualidade | Est | Sprint |
|:---:|:---|:---|:---|:---:|:---:|
| **P1** | **(Técnico)** Como dev, quero definir os tipos de Hábito e Frequência como **Enums**, para garantir consistência e evitar "magic strings". | - Os enums `TipoHabito` e `TipoFrequencia` são criados.<br>- A entidade `Habito` utiliza esses enums.<br>- A API valida e aceita os valores dos enums. | - Os valores dos enums são claros e documentados com comentários.<br>- Uma string inválida para um enum deve resultar em `400 Bad Request`. | **3h** | 1 |
| **P1** | Como usuário, quero **cadastrar um novo hábito** com nome, frequência e tipo, para poder começar a rastreá-lo. | - O endpoint `POST /habitos` deve estar funcional.<br>- Campos obrigatórios são validados.<br>- A API deve retornar `201 Created` com os dados do novo hábito. | - `HabitoController.criar()` \< 10 linhas.<br>- `HabitoService` contém a lógica de negócio.<br>- Nomenclatura clara (`HabitoDTO`).<br>- Tratamento de erros para dados inválidos. | **4h** | 1 |
| **P1** | Como usuário, quero **registrar a conclusão de um hábito** em um dia específico, para manter meu histórico atualizado. | - O endpoint `POST /diashabito` deve salvar um novo registro.<br>- Deve ser possível marcar um hábito como `concluido: true`.<br>- Associa o registro ao `habitoId` correto. | - Controller apenas delega ao `DiasHabitoService`.<br>- O serviço valida se o `habitoId` existe antes de salvar.<br>- Estrutura do `DiasHabitoDTO` é clara. | **4h** | 1 |
| **P1** | Como usuário, quero **visualizar, editar e excluir** meus hábitos, para gerenciar minha rotina de forma flexível. | - Endpoints `GET`, `PUT`, `DELETE` para `/habitos` funcionais.<br>- O sistema deve retornar `404 Not Found` se o ID não existir. | - Funções pequenas com responsabilidade única.<br>- Nomenclatura consistente (`obterPorId`, `atualizar`).<br>- A conversão de Entidade para DTO está na camada de Serviço. | **6h** | 1 |
| **P1** | **(NFR)** Como dev front-end, quero receber **respostas de erro padronizadas** e com status HTTP corretos. | - Recurso inexistente retorna `404`.<br>- Argumentos inválidos retornam `400`.<br>- Conflitos de estado retornam um erro claro. | - `@RestControllerAdvice` (`GlobalExceptionHandler`) centraliza o tratamento.<br>- Exceções customizadas (`ResourceNotFoundException`) são usadas.<br>- *Melhoria*: `IllegalStateException` deveria retornar `409 Conflict`. | **5h** | 1 |
| **P2** | **(DevOps)** Como dev, quero rodar a aplicação e o banco com **Docker Compose**, para um ambiente de dev padronizado. | - `docker-compose up` deve construir e iniciar os contêineres `app` e `postgres`.<br>- A aplicação deve estar acessível em `localhost:8080`.<br>- A aplicação deve se conectar ao banco de dados do contêiner. | - `Dockerfile` otimizado para hot-reload em dev.<br>- `docker-compose.yml` usa variáveis de ambiente (via `.env`) para senhas e nomes de banco.<br>- Health checks configurados para ambos os serviços. | **8h** | 2 |
| **P2** | Como usuário, quero poder **'iniciar' um hábito de duração**, para registrar a hora de início. | - Um endpoint `POST /diashabito/{id}/iniciar` é criado.<br>- O sistema cria um `DiasHabito` para hoje com `horaInicio`.<br>- Retorna um erro se o hábito já foi iniciado hoje. | - O método `iniciarHabito` no `DiasHabitoService` usa `@Transactional`.<br>- A lógica de negócio está totalmente contida no serviço.<br>- A exceção `IllegalStateException` é usada corretamente. | **6h** | 2 |
| **P2** | **(NFR)** Como equipe de DevOps, quero um **endpoint de Health Check**, para verificar se a aplicação está no ar. | - `GET /` deve ser acessível.<br>- Deve retornar `200 OK`.<br>- O corpo da resposta deve conter `"status": "UP"` e um timestamp. | - O Health Check deve ser leve, sem acesso a banco de dados.<br>- A resposta deve ser rápida (\< 50ms).<br>- O endpoint não deve exigir autenticação. | **2h** | 2 |
| **P2** | Como usuário, quero ver minha **maior sequência (streak)** de dias para um hábito, para me manter motivado. | - `GET /habitos/streak/{id}` retorna a lista de `DiasHabito` do maior streak.<br>- O cálculo deve respeitar a frequência do hábito. | - `FrequenciaService.buscarMaiorStreak()` é a única responsável pelo cálculo.<br>- Comentários explicam a lógica de verificação (`verificaStreakValido`). | **8h** | 2 |
| **P2** | Como usuário, quero ver minha **taxa de sucesso** para um hábito, para entender meu comprometimento. | - `GET /analytics/habito/{id}/taxa-sucesso` funciona com `inicio` e `fim`.<br>- O JSON de retorno contém `diasCompletados` e `diasEsperados`. | - `AnalyticsService` delega o cálculo para `FrequenciaService`.<br>- A função `calcularDiasEsperados` foi refatorada para não ser um *Long Method*. | **8h** | 2 |
| **P3** | **(Documentação)** Como dev front-end, quero uma **documentação da API (Swagger/OpenAPI)**, para entender os endpoints. | - Integrar a dependência `springdoc-openapi`.<br>- A UI do Swagger deve estar acessível (e.g., em `/swagger-ui.html`).<br>- Todos os endpoints do projeto devem estar documentados. | - DTOs e controllers anotados (`@Schema`, `@Operation`) para enriquecer a documentação.<br>- Exemplos de requisição e resposta devem ser claros.<br>- Descrições devem explicar o propósito de cada endpoint. | **8h** | 3 |
| **P3** | Como usuário, quero saber meu **melhor dia/período de desempenho**, para otimizar minha agenda. | - `GET /analytics/melhor-desempenho` retorna o dia da semana e período com mais hábitos concluídos.<br>- Retorna "N/A" se não houver dados. | - O método usa Streams do Java, que é uma boa prática.<br>- O código é legível e autoexplicativo.<br>- A função é coesa e focada em sua responsabilidade. | **6h** | 3 |
| **P3** | Como usuário, quero **descobrir correlações** entre meus hábitos, para identificar meus 'hábitos-chave'. | - `GET /analytics/correlacoes` retorna uma lista de correlações significativas.<br>- A correlação só é sugerida se atingir um limiar mínimo de dados. | - *Code Smell* conhecido (*Long Method*, Severidade Alta).<br>- O método precisa de comentários explicando o "porquê" da lógica.<br>- Nomenclatura das variáveis é intencional. | **12h**| 3 |
| **P3** | **(Dívida Técnica)** Escrever **testes unitários** para a camada de serviço. | - Atingir pelo menos 70% de cobertura de testes na `FrequenciaService`.<br>- Testar todos os casos de `calcularDiasEsperados`.<br>- Testar a lógica de `buscarMaiorStreak`. | - Testes usam JUnit 5 e Mockito.<br>- Nomes dos testes descritivos (`given_when_then`).<br>- Testes são independentes, rápidos e não acessam o banco real. | **16h**| 3 |
| **P4** | **(DevOps)** Como equipe de DevOps, quero configurar um **pipeline de Integração Contínua (CI)**, para garantir a qualidade do código. | - Um arquivo de pipeline (e.g., `.github/workflows/ci.yml`) é criado.<br>- O pipeline executa `mvn clean install` a cada push/pull request.<br>- O status do build (sucesso/falha) é reportado no repositório Git. | - O pipeline utiliza cache de dependências Maven para acelerar a execução.<br>- Falhas de teste devem quebrar o build e notificar a equipe.<br>- A execução do pipeline é consistente e confiável. | **10h**| 4 |
| **P4** | **(Documentação)** Como novo dev, quero um **README.md completo**, para configurar o projeto localmente em \< 15 minutos. | - O `README.md` contém: descrição, pré-requisitos, instruções de setup (`docker-compose up`), e link para a documentação da API.<br>- O arquivo `.env.example` é mencionado e explicado. | - As instruções são claras, concisas e testadas por um membro da equipe que não configurou o projeto antes.<br>- A formatação do Markdown é limpa e profissional. | **4h**| 4 |
| **P4** | **(Dívida Técnica)** Refatorar `AnalyticsService.analisarCorrelacoes` | - O método `analisarCorrelacoes` é quebrado em métodos menores.<br>- Passos como "agrupar dados", "iterar pares" e "calcular estatística" são separados.<br>- A legibilidade do método principal aumenta. | - **Critério original:** *Long Method*.<br>- **Critério final:** Função principal \< 20 linhas.<br>- Cada função extraída tem um nível único de abstração.<br>- Aumentar a cobertura de testes para a lógica. | **8h**| 4 |
| **P4** | **(Dívida Técnica)** Criar **testes de integração** para a API. | - Criar testes de integração para o fluxo de "Criar Hábito" e "Registrar Dia".<br>- Testar o endpoint `taxa-sucesso`.<br>- Os testes usam um banco de dados em memória (H2) ou Testcontainers. | - Testes cobrem o fluxo completo (Controller -\> Service -\> Repo).<br>- Usar MockMvc para simular as requisições HTTP.<br>- Os testes de integração limpam o estado do banco após cada execução. | **16h**| 4 |
| **P4** | **(Documentação)** Como Tech Lead, quero **manter a documentação de qualidade de código**, para acompanhar a evolução do projeto. | - Os arquivos `code-smells-identified.md` e `refactoring-log.md` são criados e preenchidos.<br>- A pasta `before-after-examples` é criada com exemplos claros das refatorações. | - A documentação segue os templates definidos.<br>- As justificativas para as refatorações são bem explicadas.<br>- Os exemplos de código são claros e representativos do problema e da solução. | **6h** | 4 |
| **P4** | **(DevOps)** Como equipe de DevOps, quero construir uma **imagem Docker otimizada para produção**. | - Um `Dockerfile` multi-stage é criado.<br>- A primeira etapa compila o JAR com Maven.<br>- A segunda etapa copia apenas o JAR para uma imagem JRE mínima (e.g., `...-jre-alpine`). | - A imagem final é significativamente menor que a imagem de build.<br>- A aplicação no contêiner de produção roda com um usuário não-root.<br>- A imagem é versionada e pode ser enviada para um registry (Docker Hub, etc). | **8h** | 4 |