### **Product Backlog - Projeto de Rastreamento de Hábitos (FGH)**

| Pri | User Story | Critérios de Aceitação | Critérios de Qualidade | Est | Sprint |
|:---:|:---|:---|:---|:---:|:---:|
| **P1** | Como usuário, quero **cadastrar um novo hábito** com nome, frequência e tipo, para que eu possa começar a rastreá-lo. | - O endpoint `POST /habitos` deve estar funcional.<br>- Campos obrigatórios (nome, tipoFrequencia, etc.) devem ser validados.<br>- A API deve retornar um status `201 Created` com os dados do novo hábito. | - `HabitoController.criar()` deve ser enxuto (\< 10 linhas).<br>- `HabitoService` deve conter a lógica de negócio.<br>- Nomenclatura clara (`HabitoDTO`, `TipoFrequencia`).<br>- Tratamento de erros para dados inválidos (e.g., `400 Bad Request`). | **4h** | 1 |
| **P1** | Como usuário, quero **registrar a conclusão de um hábito** em um dia específico, para manter meu histórico atualizado. | - O endpoint `POST /diashabito` deve salvar um novo registro.<br>- Deve ser possível marcar um hábito como `concluido: true`.<br>- O sistema deve associar o registro ao `habitoId` correto. | - O controller deve apenas delegar a chamada ao `DiasHabitoService`.<br>- O serviço deve validar se o `habitoId` informado existe antes de salvar.<br>- Estrutura do `DiasHabitoDTO` é clara e sem campos desnecessários. | **4h** | 1 |
| **P1** | Como usuário, quero **visualizar todos os meus hábitos** em uma lista, para ter uma visão geral da minha rotina. | - O endpoint `GET /habitos` deve retornar uma lista de todos os hábitos cadastrados.<br>- A lista não deve estar vazia se houver hábitos no banco.<br>- Cada item na lista deve ser um `HabitoDTO`. | - Nomenclatura descritiva (`listarTodos`).<br>- A conversão de Entidade para DTO é feita na camada de Serviço (Refatoração de *Duplicate Code* já aplicada).<br>- O método no controller tem responsabilidade única. | **2h** | 1 |
| **P1** | Como usuário, quero **visualizar, editar e excluir** meus hábitos, para gerenciar minha rotina de forma flexível. | - Endpoints `GET /habitos/{id}`, `PUT /habitos/{id}` e `DELETE /habitos/{id}` devem estar funcionais.<br>- O sistema deve retornar `404 Not Found` se o ID não existir.<br>- A exclusão deve remover o hábito do banco de dados. | - Funções pequenas com responsabilidade única em cada endpoint.<br>- Nomenclatura consistente (`obterPorId`, `atualizar`, `excluir`).<br>- Uso do `ResourceNotFoundException` para tratar IDs inexistentes. | **6h** | 1 |
| **P2** | Como usuário, quero ver minha **maior sequência (streak)** de dias para um hábito, para me sentir motivado a não quebrar a corrente. | - O endpoint `GET /habitos/streak/{id}` deve retornar uma lista de `DiasHabito` que compõem o maior streak.<br>- O cálculo deve respeitar a frequência do hábito (diário, dias específicos, etc.). | - `FrequenciaService.buscarMaiorStreak()` é a única responsável pelo cálculo.<br>- A lógica é bem definida e separada da camada de controller.<br>- Comentários explicam a lógica de verificação do streak (`verificaStreakValido`). | **8h** | 2 |
| **P2** | Como usuário, quero ver minha **taxa de sucesso** para um hábito, para entender meu nível de comprometimento. | - O endpoint `GET /analytics/habito/{id}/taxa-sucesso` deve funcionar com parâmetros de data `inicio` e `fim`.<br>- O JSON de retorno deve conter `diasCompletados` e `diasEsperados`.<br>- O cálculo de `diasEsperados` deve ser preciso para todos os `TipoFrequencia`. | - `AnalyticsService` delega o cálculo de dias esperados para `FrequenciaService` (Boa separação de responsabilidades).<br>- A função `calcularDiasEsperados` foi refatorada para não ser um *Long Method*. | **8h** | 2 |
| **P3** | Como usuário, quero saber meu **melhor dia/período de desempenho**, para otimizar minha agenda e alocar hábitos nos melhores horários. | - O endpoint `GET /analytics/melhor-desempenho` deve retornar o dia da semana e o período (Manhã, Tarde, Noite) com mais hábitos concluídos.<br>- Deve retornar "N/A" caso não haja dados suficientes. | - O método `encontrarMelhorDesempenho` usa Streams do Java 8+ para processamento de coleções, que é uma boa prática.<br>- A função é coesa e focada em sua responsabilidade.<br>- O código é legível e autoexplicativo, sem necessidade de comentários óbvios. | **6h** | 3 |
| **P3** | Como usuário, quero **descobrir correlações** entre meus hábitos, para identificar quais pequenas ações geram o maior impacto positivo. | - O endpoint `GET /analytics/correlacoes` retorna uma lista de correlações significativas.<br>- Uma correlação só é sugerida se o aumento de probabilidade e a quantidade de dados atingirem um limiar mínimo.<br>- Retorna um array vazio `[]` se nenhuma correlação for encontrada. | - A complexidade do método `analisarCorrelacoes` é um *Code Smell* conhecido (*Long Method*, Severidade Alta).<br>- O método precisa de comentários explicando o "porquê" da lógica estatística.<br>- Nomenclatura das variáveis é intencional (`diasComAFeito`, `taxaSucessoBComA`). | **12h**| 3 |
| **P3** | **(Dívida Técnica)** Refatorar `FrequenciaService.calcularDiasEsperados` | - O método público `calcularDiasEsperados` deve ser decomposto.<br>- A lógica de cada `case` do `switch` deve ser extraída para um método privado.<br>- Todos os testes de `taxa-sucesso` devem continuar passando. | - **Critério original:** Função longa.<br>- **Critério final:** A função principal tem \< 15 linhas e cada método extraído tem responsabilidade única.<br>- A legibilidade e manutenibilidade do serviço devem ser comprovadamente maiores. | **4h** | 4 |
| **P3** | **(Dívida Técnica)** Eliminar código duplicado nos Controllers | - A lógica de mapeamento `stream().map().collect()` deve ser removida dos métodos `listarTodos` de `HabitoController` e `DiasHabitoController`.<br>- A lógica deve ser centralizada na camada de Serviço. | - **Critério original:** Código duplicado.<br>- **Critério final:** Aderência ao princípio DRY (Don't Repeat Yourself).<br>- Controllers com responsabilidade única e mais enxutos.<br>- Formatação consistente entre os arquivos. | **3h** | 4 |
| **P3** | **(Dívida Técnica)** Refatorar `AnalyticsService.analisarCorrelacoes` | - O método `analisarCorrelacoes` deve ser quebrado em métodos menores e mais focados.<br>- Passos como "agrupar dados", "iterar pares" e "calcular estatística" devem ser separados.<br>- A legibilidade do método principal deve aumentar significativamente. | - **Critério original:** *Long Method* e baixa coesão.<br>- **Critério final:** Função principal \< 20 linhas.<br>- Cada função extraída deve ter um nível único de abstração.<br>- Aumentar a cobertura de testes para a lógica de correlação. | **8h** | 4 |